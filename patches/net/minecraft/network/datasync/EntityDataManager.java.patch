--- a/net/minecraft/network/datasync/EntityDataManager.java
+++ b/net/minecraft/network/datasync/EntityDataManager.java
@@ -5,11 +5,14 @@
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.EncoderException;
 import java.io.IOException;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 import javax.annotation.Nullable;
+
+import me.jellysquid.mods.lithium.util.lock.NullReadWriteLock;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ReportedException;
@@ -27,10 +30,34 @@
     private static final Map < Class <? extends Entity > , Integer > NEXT_ID_MAP = Maps.newHashMap();
     private final Entity entity;
     private final Map < Integer, EntityDataManager.DataEntry<? >> entries = Maps.newHashMap();
-    private final ReadWriteLock lock = new ReentrantReadWriteLock();
+
+    /**
+     * The vanilla implementation of {@link EntityDataManager} performs locking when fetching or updating data due to a legacy
+     * quirk in older versions of the game where updates would occur on a network thread for (de)serialization while entities
+     * were ticking and accessing values from it on the main thread. In newer versions (1.14+) this no longer happens.
+     * <p>
+     * The DataTracker is expected to only ever updated on the main-thread (or the thread owning it in recent versions when
+     * baking entities) during entity initialization and main-thread network updates, and as such the locking mechanism
+     * is unnecessary since the job is to only protect against simultaneous reading and writing.
+     */
+    // private final ReadWriteLock lock = new ReentrantReadWriteLock();
+    private final ReadWriteLock lock = new NullReadWriteLock();
     private boolean empty = true;
     private boolean dirty;
 
+
+    /**
+     * Optimizes the DataTracker to use a simple array-based storage for entries and avoids integer boxing. This reduces
+     * a lot of the overhead associated with retrieving tracked data about an entity.
+     */
+    private static final int DEFAULT_ENTRY_COUNT = 10, GROW_FACTOR = 8;
+
+    /**
+     * Mirrors the vanilla backing entries map. Each DataTracker.Entry can be accessed in this array through its ID.
+     */
+    private EntityDataManager.DataEntry<?>[] entriesArray = new EntityDataManager.DataEntry<?>[DEFAULT_ENTRY_COUNT];
+
+
     public EntityDataManager(Entity entityIn)
     {
         this.entity = entityIn;
@@ -117,11 +144,37 @@
     {
         EntityDataManager.DataEntry<T> dataentry = new EntityDataManager.DataEntry<>(key, value);
         this.lock.writeLock().lock();
-        this.entries.put(key.getId(), dataentry);
+        // this.entries.put(key.getId(), dataentry);
+        onAddTrackedDataInsertMap(key.getId(), dataentry); //Redirect to Lithium method
         this.empty = false;
         this.lock.writeLock().unlock();
     }
 
+    /**
+     * We redirect the call to add a tracked data to the internal map so we can add it to our new storage structure. This
+     * should only ever occur during entity initialization. Type-erasure is a bit of a pain here since we must redirect
+     * a calls to the generic Map interface.
+     */
+    private void onAddTrackedDataInsertMap(/* Integer */ int key, /* DataTracker.Entry<?> */ EntityDataManager.DataEntry<?> value) {
+
+        EntityDataManager.DataEntry<?>[] storage = this.entriesArray;
+
+        // Check if we need to grow the backing array to accommodate the new key range
+        if (storage.length <= key) {
+            // Grow the array to accommodate 8 entries after this one, but limit it to never be larger
+            // than 256 entries as per the vanilla limit
+            int newSize = Math.min(key + GROW_FACTOR, 256);
+
+            this.entriesArray = storage = Arrays.copyOf(storage, newSize);
+        }
+
+        // Update the storage
+        storage[key] = value;
+
+        // Ensure that the vanilla backing storage is still updated appropriately
+        this.entries.put(key, value);
+    }
+
     private <T> EntityDataManager.DataEntry<T> getEntry(DataParameter<T> key)
     {
         this.lock.readLock().lock();
