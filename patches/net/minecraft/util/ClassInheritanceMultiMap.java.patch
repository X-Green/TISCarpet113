--- a/net/minecraft/util/ClassInheritanceMultiMap.java
+++ b/net/minecraft/util/ClassInheritanceMultiMap.java
@@ -4,13 +4,9 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
-import java.util.AbstractSet;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
 
+import java.util.*;
+
 public class ClassInheritanceMultiMap<T> extends AbstractSet<T>
 {
     private static final Set < Class<? >> ALL_KNOWN = Sets.newHashSet();
@@ -116,8 +112,15 @@
         return Iterators.contains(this.getByClass(p_contains_1_.getClass()).iterator(), p_contains_1_);
     }
 
+    /**
+     * @reason Only perform the slow Class#isAssignableFrom(Class) if a list doesn't exist for the type, otherwise
+     * we can assume it's already valid. The slow-path code is moved to a separate method to help the JVM inline this.
+     * @author JellySquid
+     */
+    @SuppressWarnings("unchecked")
     public <S> Iterable<S> getByClass(Class<S> clazz)
     {
+        /*
         return () ->
         {
             List<T> list = this.map.get(this.initializeClassLookup(clazz));
@@ -132,8 +135,35 @@
                 return Iterators.filter(iterator, clazz);
             }
         };
+         */
+        Collection<T> collection = this.map.get(clazz);
+        if (collection == null) {
+            collection = this.createAllOfType(clazz);
+        }
+        return (Collection<S>) Collections.unmodifiableCollection(collection);
     }
 
+    /**
+     * Lithium method
+     */
+    private <S> Collection<T> createAllOfType(Class<S> type) {
+        if (!this.baseClass.isAssignableFrom(type)) {
+            throw new IllegalArgumentException("Don't know how to search for " + type);
+        }
+
+        List<T> list = new ArrayList<>();
+
+        for (T allElement : this.values) {
+            if (type.isInstance(allElement)) {
+                list.add(allElement);
+            }
+        }
+
+        this.map.put(type, list);
+
+        return list;
+    }
+
     public Iterator<T> iterator()
     {
         return (Iterator<T>)(this.values.isEmpty() ? Collections.emptyIterator() : Iterators.unmodifiableIterator(this.values.iterator()));
